---
layout: page
title: "第3章 - 本格的なプログラムを書いてみよう! (本編)"
permalink: /chapter3-2
mathjax: true
---

# 第3章 - 本格的なプログラムを書いてみよう! (本編)

第3章(準備編)では、プログラムをファイルに保存し、Geanyというソフトで編集・実行する方法について学びました。

これからいよいよC++プログラムの書き方について学んでいきます。

が、これをこのページに一から書こうとすると何ヶ月も(あるいは何年も)かかってしまうので、C++を学ぶための外部の素晴らしい教材を紹介したいと思います。

<a href="https://atcoder.jp/contests/APG4b"><font size="10">APG4b</font></a> <font size="5">(AtCoder Programming Guide for beginners)</font>

です。

APG4bでは、練習問題を解きながらC++の書き方を学ぶことができます。練習問題の解答は提出すると自動採点されるので、正しく書けているかどうかが簡単に分かります。

この教材を利用するためにはアカウント登録が必要なのですが、よく分からなかったら質問をしてください。

とりあえず2章まで読んで練習問題を解けば、C++でプログラムを書くのに必須の知識が大体身につくと思います。

ページの末尾で紹介されている「ABCの問題」も、是非解きましょう。

基本的にはこの教材の通りに進めていけば良いのですが、少し内容について補足をしたいと思います。
<br>
<br>
<br>

## その前に

前のページに「家でプログラムを書く方法を紹介する」と書いたので、まずはそれについて説明したいと思います。

実は、このAPG4bがあるサイトの機能を使うと、Geanyなどのソフトを使うことなくプログラムを編集し、実行することができます!

詳細はAPG4bの中に書いてあるので省略しますが、この機能では「実行」というボタンを押すとその前にビルドが自動で行われるので、ビルドのために別のボタンを押す必要がない、という点に注意しましょう。

パ研でプログラムを書く場合は、サイト上の機能ではなく準備編で説明した方法を使ってください。その方が色々な面で使い勝手が良いからです。

<br>

ここで、**標準入力** と **標準出力** という言葉を覚えておきましょう。

みなさんがAPG4bで作るプログラムでは、ボタンが付いていて押すと反応したり、色々な形の図形が描かれたりすることはありません。実はそのような機能というのはプログラムの本質ではないのです。

そのような飾りの機能を全て取り除き、本質部分だけを取り出したのが今からみなさんの作るプログラムです。

でも、ボタン等を一切取り除いたプログラムは、一体どうやって人とやり取りをすれば良いのでしょうか。

その役割を担ってくれるのが、標準入力と標準出力です。

みなさんがキーボードで入力した文字は、標準入力としてプログラムに送られます。一方、プログラムは表示したい文字を標準出力として画面に送ることができます。

一体どこにキーボードで文字を入力して、どこに文字が表示されるんだという話ですが、文字を入力したり、表示したりできるのが準備編でプログラムを実行したときに出てきたこの画面です。

<img src="/beginners/assets/chapter3/9.png" alt="実行" />

ただし、サイト上の機能を使う場合、入力はプログラムを実行する前に「標準入力」という欄に書いておく必要があります。また、出力は「標準出力」という欄に表示されます。

パ研でプログラムを書いている場合、次のプログラムを使って標準入力と標準出力を使ったプログラムとのやり取りを練習しましょう (プログラムの中身は分からなくて良いです)。

下のプログラムをGeanyにコピーして実行してみてください。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    cout << "あなたの名前は?" << endl;
    string name; cin >> name;
    cout << name << "さん, こんにちは!" << endl;
}
```

キーボードで自分の名前を入力したら何が起こりましたか? 手元で試してみましょう。

標準入力と標準出力を使ったやりとりはボタンなどよりも見栄えが悪く面白くないと思うかもしれませんが、これができるようになったらボタンを使ったプログラムもすぐできるので、~~我慢して~~ APG4bを頑張って下さい。

<br>
<br>
<br>
<br>
<br>
<br>

以下は、APG4bの各ページごとの細かい補足です。そのページを読んだ後に、できれば目を通しておいて下さい。
<br>
<br>
<br><br>
<br>
<br>

## M - 1.12. 文字列と文字, N - 1.13. 配列

APG4bでは、文字列の $$i$$ 文字目や配列の $$i$$ 番目にアクセスするために `配列変数.at(i)` という方法を使っています。添字の範囲が正しくない時にエラーを出してくれる点でこれは便利なのですが、実は `配列変数[i]`という方法でも(エラーを出さない以外は)同じことができます。(APG4bにも、「細かいところ」の話で一応書いてありますが...)

`配列変数.at(i)` よりも `配列変数[i]` の方が格段に読みやすいので、一般的にはこちらの方が使われています。今のうちにこちらを使う癖を付けておきましょう。エラーが出ないのは残念な点ですが、文字列・配列周りで何かがおかしかったら「添字の値がおかしいのかな」ということを意識するようにすると良いです。

あるいは、APG4bのページに書いてあるように `#define _GLIBCXX_DEBUG` をプログラムの先頭に追加するのも最初のうちは悪くないと思います。
<br>
<br>
<br>
<br>
<br>
<br>

## T - 2.03. 多次元配列

APG4bでは多次元配列、例えば3次元配列を使う時に ```vector<vector<vector<要素の型>>> 変数名(要素数1, vector<vector<要素の型>>(要素数2, vector<要素の型>(要素数3)));``` という書き方を紹介していました。

でも、これって読みにくくないですか? それに、3次元ならまだ我慢できますが、例えば5次元になるとどうなるでしょう。
<br>
```cpp
vector<vector<vector<vector<vector<int>>>>>data(10,vector<vector<vector<vector<int>>>>(20,vector<vector<vector<int>>>(30,vector<vector<int>>(40,vector<int>(50)))));
```
<br>
もう見ていられませんね。

そこで出てくるのが、N - 1.13.配列 で紹介されていた、「Cの配列」(通称)です。これを使うと、5次元の配列も次のように簡単に宣言できます。

```要素の型 変数名[要素数1][要素数2][要素数3][要素数4][要素数5];```

さっきの例だと、あの長かった宣言が

```cpp
int data[10][20][30][40][50];
```

これになります。



このような点から、特に多次元配列の場合、みなさんにはこちらの配列を使うことを推奨します。

しかし、この配列にはvectorとは使い勝手の異なる点がいくつかあるので、それを説明したいと思います。
<br>

### ① 要素数の指定に変数を使えない

まずは、このコードをコピーして実行してみてください。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
	int a = 5, b = 4;
	int data[a][b];
	data[1][2] = 3;
	cout << data[1][2] << endl;
}
```

実行できてしまった人もいるかもしれません。

でもこれはC++の標準機能ではなく、例えばみなさんがこれから家でプログラミングをするときに使う可能性の高い Visual Studio などでこれを実行してみると、エラーになってしまいます。

なので、配列の要素数の指定には **定数を使いましょう**。

要素数をどれくらい確保すればいいのか戸惑うかもしれませんが、例えばサイズ $$n \times m$$ の配列がほしくて $$n$$ が最大 $$2000$$ 、 $$m$$ が最大 $$3000$$ になるとき、 配列のサイズは $$2100 \times 3100$$ くらいにすれば良いです。 (少しサイズに余裕をもたせておくとバグが発生しにくいです)。
<br>

### ②関数の中で大きなサイズの配列を作れない

次に、このコードをコピーして実行してみてください。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
	int data[10][20][30][40][50];
	data[0][1][2][3][4] = 100;
	cout << data[0][1][2][3][4] << endl;
}
```

実行すると、プログラムは ```Segmentation fault (core dumped)``` などのエラーを出してしまったのではないかと思います。実は関数の中でサイズの大きな配列を作ろうとするとエラーが出てしまうのです。

ではどうすれば良いのでしょうか。その解決策がこちらです。

```cpp
#include <bits/stdc++.h>
using namespace std;

int data[10][20][30][40][50];

int main(){
	data[0][1][2][3][4] = 100;
	cout << data[0][1][2][3][4] << endl;
}
```

これを実行してみると、プログラムが正常に動いたのではないかと思います。

この2つのプログラムの違いは、**配列をmain関数の中で宣言したか、外で宣言したか** です。

APG4bではまだここの段階で紹介されていないのですが、実は変数は関数の外で宣言することもでき、これを **グローバル変数** と言います。グローバル変数の扱い方は、他の変数と基本的に同じだと思って良いです。この変数は複数の関数をまたいで使うこともできます。

サイズの大きな配列 (大体要素数が $$100000$$ 以上くらい) は、グローバル変数として宣言しましょう。
<br>

### ③関数の中で配列を宣言した場合、配列の要素は初期化されない

今度はこのコードをコピーして実行してみてください。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
	int data[5][4];
	cout << data[2][2] << endl;
}
```

宣言した時に配列が初期化されている場合、$$0$$ と表示されるはずです。

しかし、実行してみるとおそらくメチャクチャな値が表示されたと思います。関数の中で配列を宣言した場合、要素は初期化されないのです。

配列の要素を初期化したい場合、次のように書きましょう。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
	int data[5][4]{};
	cout << data[2][2] << endl;
}
```

この場合、ちゃんと $$0$$ と表示されたと思います。

ちなみにグローバルで宣言した配列は、何もしなくても初期化されています。
<br>
<br>
<br>
vectorではない配列を使う時の注意点は、基本的にこのくらいを覚えておけば大丈夫だと思います。

しかし、もう少し進むと困ることがあるかもしれないので (関数に配列を渡すときとか)、その時は `C++ 配列 関数` などのワードで検索してみてください (分からなかったら周りの人に聞いてください)。
<br>
<br>
<br>
<br>
<br>
<br>

## Y - 3.01. 数値型

APG4bでは `int` よりも大きな数を扱える数値型として `int64_t` を紹介していますが、競技プログラミング界ではおそらく `long long` の方が一般的に使われています。

機能はどちらを使っても同じなので (仕様上は違いますが、今の段階で困ることはありません) 好きな方で構いませんが、`long long` という型が他の人のプログラムで使われていたら、「`int64_t` と同じなんだなあ」と思っておいてください。

