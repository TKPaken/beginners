---
layout: post
title:  "JOI 2019 / 2020 2次予選 解説"
date:   2019-12-09
categories: algorithm
mathjax: true
---
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

# はじめに

まずは、JOI 予選 お疲れ様でした〜。

自分はギリギリ 全完できましたが、かなり WA とか出して苦しみました...

構文解析 が出たのはびっくりです。

競技の時は 構文解析 知らなかったので、 自己開発（？）しました。

相当時間がかかっていて、競技時間の半分以上を最終問題に費やしたことになります。

めっちゃ疲れました。体力って大事ですね...。

![JOI2019/2020-予選-結果](/begineers/assets/JOI2019-2020-yo-result.png)

# 1問目 ポスター (Poster)

<br>

![JOI2019/2020-予選A問題](/beginners/assets/JOI2019-2020-yo-problemA.png)

競技が開始されて、$$1$$問目を見た瞬間びっくりしました。

予想より遥かに難しい問題だったからです。

とはいえ、冷静に考えれば簡単です。

<br>

## 解法

![JOI2019/2020-予選A問題解説](/beginners/assets/JOI2019-2020-yo-A-editorial.png)

図のように、$$4$$通りの回転方法があります。

それぞれについて、もうひとつのポスターと違う部分の個数を数えてあげればよいです。

回転するために必要な操作の回数を加算するのを忘れないようにしましょう。

よって、 $$O(N^2)$$ で解けました。

個人的には、難易度 $$4$$ くらいかな〜と思っています。

<br><br>

# 2問目 いちご (Strawberry)

<br>

![JOI2019/2020-予選B問題](/beginners/assets/JOI2019-2020-yo-problemB.png)

そこまで難しくありません。

JOI よりは、 AtCoder という感じがしましたが...。

パズル的な発想です。

<br>

## 解法

地点 $$0$$ で待ってから、東の端まで行き、帰りにすべて取るのが最適です。

つまり、いちごのある場所の東端が分かれば、各いちごについて地点 $$0$$ で待つべき時間がわかり、その最大値が答えです。

よって、 $$O(N)$$ で解けました。

この問題も、難易度 $$4$$ 相当だと思いました。

<br><br>

# 3問目 桁和 (Digit Sum)

<br>

![JOI2019/2020-予選C問題](/beginners/assets/JOI2019-2020-yo-problemC.png)

すべての問題の中で、一番時間がかからなかったのがこの問題でした。

典型中の典型です。

<br>

## 解法

以下のような $$DP$$ を考えます。

### 定義

$$ DP[i] =$$ 結果が $$i$$ になる通り数

<br>

### 初期化

$$ DP[i]=1 $$ （最初から $$i$$ だった場合)

<br>

### 遷移

$$digitsum(N) = N$$ の桁和として、

$$DP[i+digitsum(i)]+=DP[i]$$

<br>

### 答え

$$DP[N]$$

<br>

この $$DP$$ を $$1$$ から順に回していけばよいです。

よって、$$O(N)$$ で解けました。

これは難易度 $$5$$ くらいでしょうか。


<br><br>

# 4問目 テンキー (Tenkey)

<br>

![JOI2019/2020-予選D問題-1](/beginners/assets/JOI2019-2020-yo-problemD-1.png)
![JOI2019/2020-予選D問題-2](/beginners/assets/JOI2019-2020-yo-problemD-2.png)

この問題がAランクの当落を分けたと言っても過言ではないのではないでしょうか。

<br>

## 解法

<br>

### 各キーの距離を求める

まずは、各キーの距離を求めましょう。

1. $$100$$ 通りすべて求める
2. 距離が $$1$$ のものだけ列挙して、全頂点最短経路問題を解く

どちらをやりたいですか？僕は $$2$$ 番をやりました。

[ワーシャルフロイド法](https://ja.wikipedia.org/wiki/%E3%83%AF%E3%83%BC%E3%82%B7%E3%83%A3%E3%83%AB%E2%80%93%E3%83%95%E3%83%AD%E3%82%A4%E3%83%89%E6%B3%95)を使うとやりやすいと思います。

<br>

### DPをしよう！

以下のような $$DP$$ を考えます。

<br>

#### 定義

$$ DP[i][j][k]=i$$ 桁まで決めて、$$M$$ で割ったあまりが $$j$$ で、最後に使ったキーが $$k$$ のうち、最小操作回数

<br>

#### 初期化

$$ DP[i][j][k]=inf$$

$$ DP[0][0][0]=0 $$

<br>

#### 遷移

$$l$$ は新しく使うキー

$$far[i][j]$$ は、キー $$i$$ とキー $$j$$ 間の距離

$$ chmin(x,y)$$ は、$$x$$ に $$MIN(x,y)$$ を代入する操作

$$ chmin(DP[i+1][(j \times 10 + l)\% m][l],DP[i][j][k] + far[k][l] + 1)$$

これまでの最小回数に、次のキーへの移動回数と、キーを新たに押す回数を加算すればよいです。

<br>

実は、この $$DP$$ を $$30$$ 桁くらいまでやれば確実に正しい答えが出ます。

なぜなら、$$0M+R$$の操作回数よりも、ボタンを押す操作だけで明らかに操作回数が多くなるからです。

ちなみに、$$30$$桁は、$$long long $$だとTLEしますが、$$int$$ 型だと通ります。$$(1139ms)$$

計算量は、$$DP$$ の各状態からの次のキーがそれぞれ $$10$$ ずつあるので、$$O(M \times 30 \times 10 \times 10)$$ くらいです。

$$10^8$$ くらいなので、結構ギリギリですね...。

しかし、計算する桁数は $$15$$ 桁でも十分なようです。

なぜでしょうか...？

<blockquote class="twitter-tweet"><p lang="ja" dir="ltr"><a href="https://twitter.com/Pro_ktmr?ref_src=twsrc%5Etfw">@Pro_ktmr</a> <br>終わりました<br>実際は 14 桁で足りたようです</p>&mdash; 熨斗袋 (@noshi91) <a href="https://twitter.com/noshi91/status/1204259826810769408?ref_src=twsrc%5Etfw">December 10, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>


ちなみに、他の解法としては、$$DP[i][j]=mod M$$ で $$i$$ 、最後が $$j$$ の最小として拡張ダイクストラをする方法もあるらしいです。



<br>

実は、[大手前プロコン-D-FizzBuzz](https://atcoder.jp/contests/otemae2019/tasks/otemae2019_d)で遷移の似たような問題が出題されていました。

この問題は難易度 $$7$$ くらいだと思います。

<br><br>


# 5問目 じゃんけん式 (Rock-Scissors-Paper Expression)

<br>

![JOI2019/2020-予選E問題](/beginners/assets/JOI2019-2020-yo-problemE.png)

問題見た瞬間解く気が失せますね...。

今まで見たことのないような問題のタイプです。

構文解析というらしいです。

意外と解けている人が多くてびっくり。

<br>

## 解法

![JOI2019/2020-予選E問題解説1](/beginners/assets/JOI2019-2020-yo-E-editorial1.png)

この図のように、再帰的に計算することで解くことができます。

括弧の両端がどこにあるかは、stack などを使うと、前処理で $$O(N)$$ で構築できます。

これをしないと、括弧が大量にある式の場合、括弧があるごとに終端まで走査することになり、$$O(N^2)$$ かかってしまいます。

式 $$E$$ の $$[l,r)$$ について、($$R$$ になる通り数),($$P$$ になる通り数),($$S$$ になる通り数)を返す関数を実装するとやりやすいと思います。

計算量は $$O(N)$$ ですが、少し掴みにくいと思うので図で説明します。

![JOI2019/2020-予選E問題解説2](/beginners/assets/JOI2019-2020-yo-E-editorial2.png)

この問題は、式をどういう順番で計算すればいいのかということが難しく、部分点も難しいです。

というか、計算順序が分かるなら満点取れるのでは...というのが正直なところです。

難易度 $$9$$ くらいあるんじゃないかという感じです。

<br><br>

# 総括

得点表を見たら、三分の一くらいの人が $$330$$ 点でしたね...。

3問目がもうちょっと難しかったらバラついてたかもしれません。

満点も既に $$20$$ 人以上出ていました。

去年は双子しか満点を取っていないことを考えると、実に $$10$$ 倍以上...。

ボーダーは $$350$$ か $$370$$ くらいだろうなあ〜と思っています。

これで一喜一憂することなく、本選に向けて頑張るぞい！

最後まで読んでいただきありがとうございました。

できれば拡散もよろしくお願いします。